Troubles:
- no template for input and output
- no error message is available
* 2024-01-18
1:30 time

Output:
- К сожалению, баллов, которые вы набрали, недостаточно, чтобы пройти на следующий этап. Ваш результат:
- 28.947368421052634 / 180
- Не расстраивайтесь. Возможно, нужно немного подучиться и попробовать снова, и тогда всё точно получится

** task Время-палиндром - solved (failed)
*** task
#+begin_src text

Время-палиндром

Мальчик Даня получил на свой седьмой день рождения электронные часы,
 время в которых выводится на табло в формате
 HH:MM. Ему немедленно стало интересно, сколько раз
 за сутки на часах устанавливается время-палиндром. Напомним, что
 палиндромом называется строка, которая одинаково читается слева
 направо и справа налево.

Несмотря на свой возраст, он был достаточно смышлёным ребёнком, и
 быстро посчитал, что такое событие происходит ровно 16 раз в
 день. А именно, в моменты времени 00:00, 01:10, 02:20 ... 22:22 .. 23:32.

Теперь ему стало интересно, сколько палиндромов на часах он бы насчитал, если бы в сутках было не 242424 часа, а nnn, а в одном часе не 606060 минут, а mmm. К сожалению, Даня ещё слишком мал, чтобы решать такие сложные задачи, поэтому он попросил вас помочь.

Вам необходимо по количеству часов в сутках nnn и количеству минут в часе mmm (1≤n,m<1051 \le n, m < 10^51≤n,m<105) определить, сколько раз за сутки табло часов покажет время-палиндром. Количество цифр на табло слева и справа от двоеточия одинаково и равно максимуму из длин чисел (n−1)(n - 1)(n−1) и (m−1)(m - 1)(m−1) — максимальных значений для часов и минут. Как и в обычных часах, пустые ячейки заполняются нулями.

Например, если n=12n = 12n=12, а m=1234m = 1234m=1234, то табло принимает значения от 0000:0000\texttt{0000:0000}0000:0000 до 0011:1233\texttt{0011:1233}0011:1233. Такие часы выводили бы 444 палиндрома в сутки: 0000:0000\texttt{0000:0000}0000:0000, 0001:1000\texttt{0001:1000}0001:1000, 0010:0100\texttt{0010:0100}0010:0100, 0011:1100\texttt{0011:1100}0011:1100.
Формат ввода

В первой и единственной строке входных данных записано два целых положительных числа nnn и mmm — количество часов в сутках и количество минут в часе соответственно. Ограничения: 1≤n,m<1051 \le n, m < 10^51≤n,m<105. Оба числа указаны без ведущих нулей.
Формат вывода

Выведите одно число — количество раз за сутки, когда табло часов покажет время-палиндром.
#+end_src

*** solution
#+begin_src python :results output :exports both :session s1
inp = input() # "12 1234"
n = int(inp.split(" ")[0])
m = int(inp.split(" ")[1])
found = []
r = m if n> m else n
# print(r)
l = len(str(m if n< m else n))
# print(str(r).zfill(l))
for i in range(r):
    s = str(i).zfill(l)
    rev = "".join(list(reversed(str(i).zfill(l))))
    rev_int = int(rev)
    # print("rev_int", rev_int)
    if rev_int >= m:
        continue
    # print(s, rev)
    # if str(i).zfill(l) == "".join(list(reversed(str(i).zfill(l)))):
    found.append(str(i))
print(len(found))
#+end_src

#+RESULTS:
: 4
** task Библиотека квотирования - solved (failed)
*** task
#+begin_src text
Молодой, но очень перспективный разработчик Олег к концу
 испытательного срока настолько преисполнился идеей аккаунтинга,
 лимитирования и квотирования запросов, что решил, что каждый его
 сервис будет поддерживать эти технологии. Проведя ночь с ноутбуком в
 обнимку, он написал целую библиотеку, которая позволяла бы
 ограничивать рейт запросов в свой сервис, основываясь на
 аутентификационной информации (проще говоря, токену).

Первый MVP библиотеки позволял отдельно взятому пользователю ходить в
 его сервис не более NNN раз в секунду. Таким образом, если в момент
 времени ttt пользователь uuu отправил запрос, то он будет пропущен
 (принят), если пользователь uuu сделал с момента времени t−1 сек.t -
 \text{1 сек.}t−1 сек. меньше NNN запросов.

Смекнув, что в случае нерабочего кода тут пахнет серьезными денежными
 потерями, Олег покрыл практически всю свою библиотеку unit-тестами.

Тесты подавали на вход записанный упрощенный лог запросов, вида:

1 10000
1676217286000 AYjcyMzY3ZDhiNmJkNTY
1676217286009 RjY2NjM5NzA2OWJjuE7c
1676217286010 AYjcyMzY3ZDhiNmJkNTY
1676217286010 RjY2NjM5NzA2OWJjuE7c
1676217286100 AYjcyMzY3ZDhiNmJkNTY
1676217286199 RjY2NjM5NzA2OWJjuE7c
1676217287012 RjY2NjM5NzA2OWJjuE7c
1676217287612 RjY2NjM5NzA2OWJjuE7c
...
1676217892348 Th7UHJdLswIYQxwSg29D

Где первая строка указывала рейт запросов в секунду и количество
 записей лога запроса, а последующие - лог запросов, в которых первое
 поле - расширенный unix timestamp с миллисекундной точностью, а
 второе - OAuth токен пользователя.

На выходе тесты проверяли статус запроса: будет ли он пропущен или
 нет. При этом выводились только пропущенные запросы:

1676217286000 AYjcyMzY3ZDhiNmJkNTY
1676217286009 RjY2NjM5NzA2OWJjuE7c
...
1676217892348 Th7UHJdLswIYQxwSg29D

К сожалению, утром за день до конца испытательного срока Олег узнал,
 что его библиотека умерла вместе с жестким диском, но зато остались
 живы тесты, которые он успел закоммитить. Олег просит Вас помочь с
 его проблемой, восстановив утерянную функциональнось.

 Формат ввода

На вход даются два числа NNN и KKK, разделенные пробельными символами, где 1≤N≤1061 \leq N \leq 10^61≤N≤106, 1≤K≤1061 \leq K \leq 10^61≤K≤106.

Далее следуют KKK строк, каждая из которых содержит 2 поля: расширенный Unix-timestamp с миллисекундной точностью (unsigned 64-bit integer), и строку - токен, идентифицирующий пользователя. Токен имеет размер в точности равный 20 символов из [a-zA-Z0-9] алфавита.

Гарантируется, что ввод отсортирован по первому полю (timestamp) и что каждая строка всегда оканчивается символом \n. Суммарное количество пользователей не превышает 1000.
Формат вывода

В ответе нужно вывести тот же самый лог запросов, оставив из него только те запросы, которые будут приняты (не будут отфильтрованы).

Обратите внимание, что каждую строку следует выводить без изменений, включая символ \n в конце строки.
Пример 1
Ввод

1 1
1679981968781 0fdc847ecc495d6dd584

Вывод

1679981968781 0fdc847ecc495d6dd584

Пример 2
Ввод

2 4
1679982033000 441079aa62dc3cd57df3
1679982033998 441079aa62dc3cd57df3
1679982033999 441079aa62dc3cd57df3
1679982034000 441079aa62dc3cd57df3

Вывод

1679982033000 441079aa62dc3cd57df3
1679982033998 441079aa62dc3cd57df3
1679982034000 441079aa62dc3cd57df3

Примечание

В этой задаче большой объем входных и выходных данных. Рекомендуется использовать построчный ввод/вывод, иначе возможен выход за пределы допустимой памяти.
#+end_src

*** solution
#+begin_src python :results output :exports both :session s1
# solution = """2 4
# 1679982033000 441079aa62dc3cd57df3
# 1679982033998 441079aa62dc3cd57df3
# 1679982033999 441079aa62dc3cd57df3
# 1679982034000 441079aa62dc3cd57df3"""
solution = input()
# print(solution)
p1 = solution.split("\n")[0]
n = int(p1.split(" ")[0])
m = p1.split(" ")[1]
solution = []
for _ in range(m):
    solution = input()
pn = solution.split("\n")
# print(n, m)
sl = 0
sl2 = ""
processed = dict()
save = []
for l in pn:
    l1 = int(l.split(" ")[0])
    l2 = l.split(" ")[1]
    # print(l1 -sl)
    k = processed[l2] if l2 in processed else 0
    if l1 - k >= n :
        processed[l2] = l1
        save.append(l)
[print(x) for x in save]
#+end_src

#+RESULTS:
: 1679982033000 441079aa62dc3cd57df3
: 1679982033998 441079aa62dc3cd57df3
: 1679982034000 441079aa62dc3cd57df3
** Музыкальный лейбл - not solved
#+begin_src text
Музыкальный лейбл аккумулировал вокруг себя тысячи артистов и собрал в своем архиве бессчетное количество треков, музыкальных партий и битов. Накопленной музыкой лейбл активно делится со своими нынешними артистами.

Архив с музыкой – это дерево ресурсов, в котором есть два типа узлов: директории и файлы. Файлы – это узлы у которых нет “детей”. То есть листовые узлы, которые содержат конкретное музыкальное произведение. Директории – это узлы у которых могут быть “дети”, по сути это папка с музыкальными произведениями.

У каждого узла есть имя. У “детей” одной директории уникальные имена. Полный путь определяется названиями узлов разделенные знаками /, например:

/ – это корневая директория.

/Release – это директория с именем Release внутри корневой директории.

/Release/Echoes_of_Eternit – это директория Echoes_of_Eternit внутри директории Release.

/Release/Echoes_of_Eternit/Supernova.flac – это файл Supernova.flac внутри директории Echoes_of_Eternit.

Недавно лейбл столкнулся с проблемой: сломался сервис выдачи прав и работа многих артистов остановилась. Если артисты не работают, лейбл теряет деньги, а слушатели не получают новые релизы. Вас позвали на помощь. Ваша задача: написать сервис, который выдает пользователям (артистам и администраторам) права на узлы дерева и эти права проверяет.

По умолчанию, у пользователей отсутствуют какие-либо права. Есть два режима прав, read и write – права на чтение и на запись файлов и директорий.

Чаще всего артисты получают права на чтение (они нужны, чтобы прослушивать и семпилировать музыкальные треки), а администраторы лейбла права на запись (админы чаще просто добавляют новые релизы). Права на чтение и на запись выдаются отдельно. У пользователя могут быть права как на чтение, так и на запись. При этом последняя операция выдачи права является более приоритетной.

Есть три операции:

grant user mode path – выдает доступ с режимом mode пользователю user на узел с путем равным path. Ответ – это строка done

block user mode path – запрещает доступ с режимом mode пользователю user на узел c путем равным path. Ответ – это строка done

check user mode path – проверяет, есть ли у пользователя user права с режимом mode до узла с путем равным path. Ответ – это строка allowed или forbidden.

Все выданные права и запреты наследуются вниз по дереву. При этом, если возникает противоречие, правила, определенные ниже по дереву, имеют более высокий приоритет.
Формат ввода

В каждой строке входного файла записана одна из команд grant, block или check, с параметрами useruseruser, modemodemode и pathpathpath.

    useruseruser &ndash; имя пользователя, непустая строка, длина не превышает 202020.
    modemodemode &ndash; режим доступа, строка со значением read или write.
    pathpathpath &ndash; путь до узла, непустая строка, всегда начинается с символа /, длина не превышает 5000050 00050000.
    Количество команд не превышает 5000050 00050000.
    Количество пользователей не превышает 5000050 00050000.
    Количество узлов в дереве ресурсов не превышает 100000100 000100000.
    Имя узла &ndash; непустая строка, длина не превышает 202020.
    Разрешенные символы в названиях узлов и именах пользователей: a-z, A-Z, 0-9, ., _.
    Размер входного файла не превышает 1 MiB1 \mskip3mu MiB1MiB.

Формат вывода

Для каждой команды выведите результат ее выполнения.

    Для команд grant и block, это всегда строка со значением done.
    Для команды check, это строка со значением allowed, если доступ разрешен, или forbidden, если в доступе отказано.

Пример
Ввод

grant bob read /home/bob
block bob read /
check bob read /home/bob/Pictures/gary.jpg
check bob read /etc/shadow
check bob write /home/bob/Pictures/gary.jpg
grant bob write /home/bob
check bob write /home/bob/Pictures/gary.jpg
block bob write /home/bob/Pictures
check bob write /home/bob/Pictures/gary.jpg
check bob read /home/bob/Pictures/gary.jpg
grant root read /
check root read /home/bob/Pictures/gary.jpg
check root read /etc/shadow

Вывод

done
done
allowed
forbidden
forbidden
done
allowed
done
forbidden
allowed
done
allowed
allowed

#+end_src
* 2024-03-14
** task1 (solved) (2.07s when required <2)
*** task
#+begin_src text
Ограничение времени 	2 секунды
Ограничение памяти 	256.0 Мб
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

Дан массив aa, элементами которого могут быть целые числа или массивы такой же структуры. Некоторые массивы могут быть пустыми или содержать только один вложенный массив.

Например массив может иметь следующую структуру: [1, 2, 3, [5, 5], 6, [7, 8, 9, [10, 11]]].

Если интерпретировать массив как простую последовательность чисел, определите элементы в массиве, который встречается наибольшее количество раз.
Формат ввода

В единственной строке записано представление массива. Элементы массива (числа и массивы) разделены запятой и пробелом. Перед первым элементом каждого массива записан символ '[', после последнего элемента записан символ ']'.

Гарантируется, что все числа по абсолютной величине менее 109109. В массиве есть хотя бы одно число.

Размер входных данных не превышает 1MB.
Формат вывода

Выведите все числа, которые встречаются в массиве aa наибольшее количество раз. Числа нужно выводить в порядке возрастания, разделяя одиночными пробелами.

Ввод
Вывод

[1, 2, 3, [5, 5], 6, [7, 8, 9, [10, 11]]]



5

Пример 2
Ввод
Вывод

[[[[[[1]]]], []]]



1

Пример 3
Ввод
Вывод

[5, 5, 1, 3, 1, 2]



1 5

Пример 4
Ввод
Вывод

[0, 10, 2, 5, -999999999]



-999999999 0 2 5 10

#+end_src

*** solution
#+begin_src python :results output :exports both :session s1
# import numpy as np

# def mode(lst):
#     """
#     Numpy
#     Find mode - most frequent element in the list.
#     """
#     x = np.array(lst)

#     #find unique values in array along with their counts
#     vals, counts = np.unique(x, return_counts=True)

#     #find mode
#     mode_value = np.argwhere(counts == np.max(counts))

#     #print list of modes
#     return " ".join([str(x) for x in sorted(vals[mode_value].flatten().tolist())])
import sys

def mode(numbers):
    largestCount = 0
    modes = []
    for x in numbers:
        if x in modes:
            continue
        count = numbers.count(x)
        if count > largestCount:
            del modes[:]
            modes.append(x)
            largestCount = count
        elif count == largestCount:
            modes.append(x)
    return " ".join([str(x) for x in sorted(modes)])

def process_input(lines):
    r = []
    lines = ''.join( c for c in lines if  c not in '[],' )
    for line in lines.split("\n"): # lines.replace("[", "").replace("]", "").replace(",", "")
        if not line:
            break
        c = line.split(" ")
        # flat_list = str([x.replace(",", "").replace("\n", "") for x in c]).replace("'", "")
        # digits = ast.literal_eval(str(flat_list))
        # print(c)
        digits = [int(x) for x in c if x]
        # print(c, digits)
        r.append(mode(digits))
    return(r)

def main():
    # Считываем входные данные
    if len(sys.argv) > 1 and sys.argv[1] == 'input.txt':
        with open('input.txt') as f:
            input = f.read()
    else:
        input = sys.stdin.read()

    # Обработка входных данных
    result = process_input(input)

    # Вывод результата
    with open('output.txt', "w") as f:
        for x in result:
            f.writelines((x,"\n"))
        # input = f.read()


if __name__ == '__main__':
    # try:
    main()

#+end_src

#+RESULTS:
: 5
: 1
: 1 5
: -999999999 0 2 5 10

** task2 (unsolved)
#+begin_src text
B. Индекс спроса [cloned]
Ограничение времени 	8 секунд
Ограничение памяти 	256.0 Мб
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

Представим запросы по доставке товаров точками на декартовой плоскости. Для удобства будем считать, что все точки имеют целочисленные координаты.

Даны nn точек заказов за определенный период. Для определения очагов спроса нужно определить, какое наибольшее количество заказов попало в некоторый прямоугольник площади ss (со сторонами параллельными осям координат) и сами эти заказы.

Обратите внимание. У выбранного прямоугольника стороны не обязательно буду иметь целые значения, но каждая из них должна быть не менее 1.

Заказы, координаты которых попадают на границу прямоугольника, считаются попадающими в область.
Формат ввода

В первой строке записаны два целых числа nn и ss (2≤n≤3002≤n≤300, 1≤s≤1061≤s≤106).

В каждой из следующих nn строк записаны координаты одного из заказов xixi​, yiyi​ (0≤xi,yi≤20000≤xi​,yi​≤2000).

Обратите внимание, что из одной точки может быть сделано несколько заказов.
Формат вывода

В первой строке выведите число kk (1≤k≤n1≤k≤n) — найденные заказы.

Во второй строке выведите kk различных индексов i1i1​ \ldots ikik​ (1≤i1<…<ik≤n1≤i1​<…<ik​≤n) — заказы, для которых окаймляющий прямоугольник имеет площадь не более ss (если сторона менее 1, то она будет увеличена до 1).

Если подходящих наборов заказов несколько (их ровно kk и попадают в подходящую область), то вы можете вывести любой из таких наборов.


: Нужно найти количество заказов и индексы заказов, попадающих в
: окаймляющий прямоугольник площадью не более заданной, стороны
: которого параллельны осям координат.

input.txt:
5 1
0 0
0 2
2 0
1 1
2 2
output:
2
1 4


5 2
0 0
0 2
2 0
1 1
2 2
output:
3
1 3 4


5 4
0 0
0 2
2 0
1 1
2 2
output:
5
1 2 3 4 5

#+end_src
** task3 (unsolved)
#+begin_src text
C. Таргетинг на погоду [cloned]
Ограничение времени 	3 секунды
Ограничение памяти 	256.0 Мб
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

Осень уже в самом разгаре --- а это значит, что нас всех ждут и дождливые, и тёплые дни. В дождь людям нужны зонты и дождевики, и производителям этих товаров крайне важно отслеживать рост интереса к ним. С другой стороны, производителям прохладительных напитков важны тёплые дни, когда на продвижение можно потратить бóльшие бюджеты.

Итак, владельцам рекламных объявлений определённых тематик требуется возможность управлять настройками показов в зависимости от погоды. В этой задаче вам потребуется реализовать простейшую версию этой функциональности --- таргетинг на температуру в определённые диапазоны дней.

В вашем распоряжении есть исторические данные о температуре, а также прогноз на ближайшее будущее. А именно:

    температура сегодня (этот день имеет номер 00);
    температура за прошедшие NN дней (вчерашний имеет номер −1−1, позавчерашний --- −2−2 и так далее до дня −N−N, самого раннего из известных);
    прогноз температуры на ближайшие NN дней (завтрашний имеет номер 11, послезавтрашний --- 22 и так далее до дня NN).

Кроме того, есть данные о настройках показа BB рекламных объявлений. Каждому из них соответствуют четыре числа tmintmin​, tmaxtmax​, dmindmin​, dmaxdmax​, означающие, что объявление можно показывать только в том случае, если за период от дня dmindmin​ до дня dmaxdmax​ включительно температура принимала или примет значение от tmintmin​ до tmaxtmax​ включительно. При этом гарантируется, что dmin≤0≤dmaxdmin​≤0≤dmax​, то есть диапазон дней должен включать сегодняшний.

Обратите внимание, что температура не дискретна! Например, если вчера значение температуры было −5−5, а сегодня −2−2, то необходимо считать, что в период, включающий сегодняшний и вчерашний дни, температура принимала не только значения −5−5 и −2−2, но и −4−4 и −3−3 (и даже −3,14−3,14, но в этой задаче все входные данные целочисленны).

Для каждого рекламного объявления определите, может ли оно быть показано в текущий день с учётом настроек и известных погодных данных.
Формат ввода

В первой строке входного файла вводится единственное целое неотрицательное число NN (N≤100000N≤100000).

В следующей строке вводится 2N+12N+1 целых чисел --- значения температуры в дни −N−N, −N+1−N+1, ..., −1−1, 00, 11, ..., NN. Значения температуры по модулю не превосходят 109109.

В третьей строке содержится единственное целое положительное число BB (B≤100000B≤100000) --- количество рекламных объявлений.

Наконец, в каждой из следующих BB строк содержатся 4 целых числа tmintmin​, tmaxtmax​, dmindmin​, dmaxdmax​, описывающие настройки соответствующего объявления. Гарантируется, что −109≤tmin≤tmax≤109−109≤tmin​≤tmax​≤109 и −N≤dmin≤0≤dmax≤N−N≤dmin​≤0≤dmax​≤N.
Формат вывода

Для каждого из объявлений выведите в отдельной строке «yes», если оно может быть показано согласно настройкам, и «no» в противном случае.
Пример
Ввод
Вывод

2
2 4 5 -2 2
4
-1 -1 -1 1
0 10 -1 0
6 8 -2 2
3 3 -1 0



yes
yes
no
no

Примечания

В задаче большой объем входных и выходных данных, для решения на Java используйте буферизированный ввод. Не используйте для чтения класс Scanner. Для вывода не используйте System.out.printf(), String.format(), используйте System.out.println() или OutputStreamWriter. Для буферизированного вывода не забывайте вызывать OutputStreamWriter.flush() перед выходом из приложения.

#+end_src
