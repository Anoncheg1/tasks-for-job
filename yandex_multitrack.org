1:30 time

Output:
- К сожалению, баллов, которые вы набрали, недостаточно, чтобы пройти на следующий этап. Ваш результат:
- 28.947368421052634 / 180
- Не расстраивайтесь. Возможно, нужно немного подучиться и попробовать снова, и тогда всё точно получится
* task Время-палиндром
** task

Время-палиндром

Мальчик Даня получил на свой седьмой день рождения электронные часы,
 время в которых выводится на табло в формате
 HH:MM. Ему немедленно стало интересно, сколько раз
 за сутки на часах устанавливается время-палиндром. Напомним, что
 палиндромом называется строка, которая одинаково читается слева
 направо и справа налево.

Несмотря на свой возраст, он был достаточно смышлёным ребёнком, и
 быстро посчитал, что такое событие происходит ровно 16 раз в
 день. А именно, в моменты времени 00:00, 01:10, 02:20 ... 22:22 .. 23:32.

Теперь ему стало интересно, сколько палиндромов на часах он бы насчитал, если бы в сутках было не 242424 часа, а nnn, а в одном часе не 606060 минут, а mmm. К сожалению, Даня ещё слишком мал, чтобы решать такие сложные задачи, поэтому он попросил вас помочь.

Вам необходимо по количеству часов в сутках nnn и количеству минут в часе mmm (1≤n,m<1051 \le n, m < 10^51≤n,m<105) определить, сколько раз за сутки табло часов покажет время-палиндром. Количество цифр на табло слева и справа от двоеточия одинаково и равно максимуму из длин чисел (n−1)(n - 1)(n−1) и (m−1)(m - 1)(m−1) — максимальных значений для часов и минут. Как и в обычных часах, пустые ячейки заполняются нулями.

Например, если n=12n = 12n=12, а m=1234m = 1234m=1234, то табло принимает значения от 0000:0000\texttt{0000:0000}0000:0000 до 0011:1233\texttt{0011:1233}0011:1233. Такие часы выводили бы 444 палиндрома в сутки: 0000:0000\texttt{0000:0000}0000:0000, 0001:1000\texttt{0001:1000}0001:1000, 0010:0100\texttt{0010:0100}0010:0100, 0011:1100\texttt{0011:1100}0011:1100.
Формат ввода

В первой и единственной строке входных данных записано два целых положительных числа nnn и mmm — количество часов в сутках и количество минут в часе соответственно. Ограничения: 1≤n,m<1051 \le n, m < 10^51≤n,m<105. Оба числа указаны без ведущих нулей.
Формат вывода

Выведите одно число — количество раз за сутки, когда табло часов покажет время-палиндром.
** solution
#+begin_src python :results output :exports both :session s1
inp = input() # "12 1234"
n = int(inp.split(" ")[0])
m = int(inp.split(" ")[1])
found = []
r = m if n> m else n
# print(r)
l = len(str(m if n< m else n))
# print(str(r).zfill(l))
for i in range(r):
    s = str(i).zfill(l)
    rev = "".join(list(reversed(str(i).zfill(l))))
    rev_int = int(rev)
    # print("rev_int", rev_int)
    if rev_int >= m:
        continue
    # print(s, rev)
    # if str(i).zfill(l) == "".join(list(reversed(str(i).zfill(l)))):
    found.append(str(i))
print(len(found))
#+end_src

#+RESULTS:
: 4
* task Библиотека квотирования
** task
Молодой, но очень перспективный разработчик Олег к концу
 испытательного срока настолько преисполнился идеей аккаунтинга,
 лимитирования и квотирования запросов, что решил, что каждый его
 сервис будет поддерживать эти технологии. Проведя ночь с ноутбуком в
 обнимку, он написал целую библиотеку, которая позволяла бы
 ограничивать рейт запросов в свой сервис, основываясь на
 аутентификационной информации (проще говоря, токену).

Первый MVP библиотеки позволял отдельно взятому пользователю ходить в
 его сервис не более NNN раз в секунду. Таким образом, если в момент
 времени ttt пользователь uuu отправил запрос, то он будет пропущен
 (принят), если пользователь uuu сделал с момента времени t−1 сек.t -
 \text{1 сек.}t−1 сек. меньше NNN запросов.

Смекнув, что в случае нерабочего кода тут пахнет серьезными денежными
 потерями, Олег покрыл практически всю свою библиотеку unit-тестами.

Тесты подавали на вход записанный упрощенный лог запросов, вида:

1 10000
1676217286000 AYjcyMzY3ZDhiNmJkNTY
1676217286009 RjY2NjM5NzA2OWJjuE7c
1676217286010 AYjcyMzY3ZDhiNmJkNTY
1676217286010 RjY2NjM5NzA2OWJjuE7c
1676217286100 AYjcyMzY3ZDhiNmJkNTY
1676217286199 RjY2NjM5NzA2OWJjuE7c
1676217287012 RjY2NjM5NzA2OWJjuE7c
1676217287612 RjY2NjM5NzA2OWJjuE7c
...
1676217892348 Th7UHJdLswIYQxwSg29D

Где первая строка указывала рейт запросов в секунду и количество
 записей лога запроса, а последующие - лог запросов, в которых первое
 поле - расширенный unix timestamp с миллисекундной точностью, а
 второе - OAuth токен пользователя.

На выходе тесты проверяли статус запроса: будет ли он пропущен или
 нет. При этом выводились только пропущенные запросы:

1676217286000 AYjcyMzY3ZDhiNmJkNTY
1676217286009 RjY2NjM5NzA2OWJjuE7c
...
1676217892348 Th7UHJdLswIYQxwSg29D

К сожалению, утром за день до конца испытательного срока Олег узнал,
 что его библиотека умерла вместе с жестким диском, но зато остались
 живы тесты, которые он успел закоммитить. Олег просит Вас помочь с
 его проблемой, восстановив утерянную функциональнось.

 Формат ввода

На вход даются два числа NNN и KKK, разделенные пробельными символами, где 1≤N≤1061 \leq N \leq 10^61≤N≤106, 1≤K≤1061 \leq K \leq 10^61≤K≤106.

Далее следуют KKK строк, каждая из которых содержит 2 поля: расширенный Unix-timestamp с миллисекундной точностью (unsigned 64-bit integer), и строку - токен, идентифицирующий пользователя. Токен имеет размер в точности равный 20 символов из [a-zA-Z0-9] алфавита.

Гарантируется, что ввод отсортирован по первому полю (timestamp) и что каждая строка всегда оканчивается символом \n. Суммарное количество пользователей не превышает 1000.
Формат вывода

В ответе нужно вывести тот же самый лог запросов, оставив из него только те запросы, которые будут приняты (не будут отфильтрованы).

Обратите внимание, что каждую строку следует выводить без изменений, включая символ \n в конце строки.
Пример 1
Ввод

1 1
1679981968781 0fdc847ecc495d6dd584

Вывод

1679981968781 0fdc847ecc495d6dd584

Пример 2
Ввод

2 4
1679982033000 441079aa62dc3cd57df3
1679982033998 441079aa62dc3cd57df3
1679982033999 441079aa62dc3cd57df3
1679982034000 441079aa62dc3cd57df3

Вывод

1679982033000 441079aa62dc3cd57df3
1679982033998 441079aa62dc3cd57df3
1679982034000 441079aa62dc3cd57df3

Примечание

В этой задаче большой объем входных и выходных данных. Рекомендуется использовать построчный ввод/вывод, иначе возможен выход за пределы допустимой памяти.
** solution
#+begin_src python :results output :exports both :session s1
# solution = """2 4
# 1679982033000 441079aa62dc3cd57df3
# 1679982033998 441079aa62dc3cd57df3
# 1679982033999 441079aa62dc3cd57df3
# 1679982034000 441079aa62dc3cd57df3"""
solution = input()
# print(solution)
p1 = solution.split("\n")[0]
n = int(p1.split(" ")[0])
m = p1.split(" ")[1]
solution = []
for _ in range(m):
    solution = input()
pn = solution.split("\n")
# print(n, m)
sl = 0
sl2 = ""
processed = dict()
save = []
for l in pn:
    l1 = int(l.split(" ")[0])
    l2 = l.split(" ")[1]
    # print(l1 -sl)
    k = processed[l2] if l2 in processed else 0
    if l1 - k >= n :
        processed[l2] = l1
        save.append(l)
[print(x) for x in save]
#+end_src

#+RESULTS:
: 1679982033000 441079aa62dc3cd57df3
: 1679982033998 441079aa62dc3cd57df3
: 1679982034000 441079aa62dc3cd57df3
* Музыкальный лейбл - not solved

Музыкальный лейбл аккумулировал вокруг себя тысячи артистов и собрал в своем архиве бессчетное количество треков, музыкальных партий и битов. Накопленной музыкой лейбл активно делится со своими нынешними артистами.

Архив с музыкой – это дерево ресурсов, в котором есть два типа узлов: директории и файлы. Файлы – это узлы у которых нет “детей”. То есть листовые узлы, которые содержат конкретное музыкальное произведение. Директории – это узлы у которых могут быть “дети”, по сути это папка с музыкальными произведениями.

У каждого узла есть имя. У “детей” одной директории уникальные имена. Полный путь определяется названиями узлов разделенные знаками /, например:

/ – это корневая директория.

/Release – это директория с именем Release внутри корневой директории.

/Release/Echoes_of_Eternit – это директория Echoes_of_Eternit внутри директории Release.

/Release/Echoes_of_Eternit/Supernova.flac – это файл Supernova.flac внутри директории Echoes_of_Eternit.

Недавно лейбл столкнулся с проблемой: сломался сервис выдачи прав и работа многих артистов остановилась. Если артисты не работают, лейбл теряет деньги, а слушатели не получают новые релизы. Вас позвали на помощь. Ваша задача: написать сервис, который выдает пользователям (артистам и администраторам) права на узлы дерева и эти права проверяет.

По умолчанию, у пользователей отсутствуют какие-либо права. Есть два режима прав, read и write – права на чтение и на запись файлов и директорий.

Чаще всего артисты получают права на чтение (они нужны, чтобы прослушивать и семпилировать музыкальные треки), а администраторы лейбла права на запись (админы чаще просто добавляют новые релизы). Права на чтение и на запись выдаются отдельно. У пользователя могут быть права как на чтение, так и на запись. При этом последняя операция выдачи права является более приоритетной.

Есть три операции:

grant user mode path – выдает доступ с режимом mode пользователю user на узел с путем равным path. Ответ – это строка done

block user mode path – запрещает доступ с режимом mode пользователю user на узел c путем равным path. Ответ – это строка done

check user mode path – проверяет, есть ли у пользователя user права с режимом mode до узла с путем равным path. Ответ – это строка allowed или forbidden.

Все выданные права и запреты наследуются вниз по дереву. При этом, если возникает противоречие, правила, определенные ниже по дереву, имеют более высокий приоритет.
Формат ввода

В каждой строке входного файла записана одна из команд grant, block или check, с параметрами useruseruser, modemodemode и pathpathpath.

    useruseruser &ndash; имя пользователя, непустая строка, длина не превышает 202020.
    modemodemode &ndash; режим доступа, строка со значением read или write.
    pathpathpath &ndash; путь до узла, непустая строка, всегда начинается с символа /, длина не превышает 5000050 00050000.
    Количество команд не превышает 5000050 00050000.
    Количество пользователей не превышает 5000050 00050000.
    Количество узлов в дереве ресурсов не превышает 100000100 000100000.
    Имя узла &ndash; непустая строка, длина не превышает 202020.
    Разрешенные символы в названиях узлов и именах пользователей: a-z, A-Z, 0-9, ., _.
    Размер входного файла не превышает 1 MiB1 \mskip3mu MiB1MiB.

Формат вывода

Для каждой команды выведите результат ее выполнения.

    Для команд grant и block, это всегда строка со значением done.
    Для команды check, это строка со значением allowed, если доступ разрешен, или forbidden, если в доступе отказано.

Пример
Ввод

grant bob read /home/bob
block bob read /
check bob read /home/bob/Pictures/gary.jpg
check bob read /etc/shadow
check bob write /home/bob/Pictures/gary.jpg
grant bob write /home/bob
check bob write /home/bob/Pictures/gary.jpg
block bob write /home/bob/Pictures
check bob write /home/bob/Pictures/gary.jpg
check bob read /home/bob/Pictures/gary.jpg
grant root read /
check root read /home/bob/Pictures/gary.jpg
check root read /etc/shadow

Вывод

done
done
allowed
forbidden
forbidden
done
allowed
done
forbidden
allowed
done
allowed
allowed
